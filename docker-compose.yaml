version: "3.9"

services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: ${DB_NAME:-whaticket}
      POSTGRES_USER: ${DB_USER:-whaticket}
      POSTGRES_PASSWORD: ${DB_PASS:-mude}
      TZ: ${TZ:-America/Sao_Paulo}
    volumes:
      - pg_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-postgres} -d $${POSTGRES_DB:-postgres}"]
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    command: ["redis-server", "--appendonly", "yes", "--maxmemory-policy", "allkeys-lru"]
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
    restart: unless-stopped

  api:
    build:
      context: https://github.com/gian0205/whaticketsaas.git#master
      dockerfile: backend/Dockerfile
    # Adicionamos nosso script de entrypoint para rodar as migrações
    entrypoint: ["/bin/sh", "-c", "chmod +x /entrypoint-api.sh && /entrypoint-api.sh node server.js"]
    volumes:
      # Mapeamos o script para dentro do contêiner
      - ./entrypoint-api.sh:/entrypoint-api.sh
      - storage:/app/public
    environment:
      TZ: ${TZ:-America/Sao_Paulo}
      NODE_ENV: production
      PORT: "4000"
      PUBLIC_DOMAIN: ${PUBLIC_DOMAIN:-whaticket.nepal.decorafit.com.br}
      BACKEND_URL: https://${PUBLIC_DOMAIN:-whaticket.nepal.decorafit.com.br}/api
      FRONTEND_URL: https://${PUBLIC_DOMAIN:-whaticket.nepal.decorafit.com.br}
      DB_HOST: db
      REDIS_HOST: redis
      # ... (mantenha suas outras variáveis de ambiente DB_ e JWT_)
      DB_USER: ${DB_USER:-whaticket}
      DB_PASS: ${DB_PASS:-mude}
      DB_NAME: ${DB_NAME:-whaticket}
      JWT_SECRET: ${JWT_SECRET:-troque}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET:-troque2}
      RUN_SEEDS: ${RUN_SEEDS:-false}
    depends_on:
      db: { condition: service_healthy }
      redis: { condition: service_healthy }
    restart: unless-stopped

  web:
    # A mágica acontece aqui: construímos uma imagem em vez de usar uma pronta
    build:
      context: . # Usa o diretório atual como contexto
      dockerfile: - # Define o Dockerfile diretamente aqui
      args:
        # Passa o script como um argumento para o Dockerfile
        ENTRYPOINT_SCRIPT: ${ENTRYPOINT_WEB_SCRIPT:-$(cat entrypoint-web.sh)}
    image: whaticket-frontend-custom
    stdin_open: true # Necessário para passar o script como argumento
    ports:
      - "80"
    depends_on:
      - api
    restart: unless-stopped

volumes:
  pg_data:
  redis_data:
  storage:
